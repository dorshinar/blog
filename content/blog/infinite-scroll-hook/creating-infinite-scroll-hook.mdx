---
title: "Creating Infinite Scroll Hook in React"
date: "2021-03-20"
description: "Infinite scrolling is a great way to only fetch what the user can see, while still feeling like there's more to scroll. Let's implement that in React."
slug: "/create-react-infinite-scroll-hook"
---

import SimpleListContainer from "./SimpleListContainer.jsx";
import SimpleList from "./SimpleList.jsx";
import CodeShiftingBox from "./ColorShiftingBox.jsx";
import SimpleListWithHook from "./SimpleListWithHook.jsx";
import Checkbox from "../../../src/components/Checkbox.jsx";

<Checkbox checked /> 
Often we want to render lists of items. It could be facebook posts, articles in this very own blog or products in an e-commerce site.

If we had all the compute power in the world and network wasn't an issue, we'd simply download the entire feed when first loading the page, and let our users scroll for hours on end.

Sadly, we're usually constrained by compute, network, or both, and that forces us to compromise. In our case, we must give up trying to load the entire list in the client's device. think about it - _very_ large lists full of information can be several magebytes large!

The 'Fast 3G' network preset in Chrome's dev tools is clocked at 1.5Mb/s. At those rates, downloading several megabytes worth of products information is simply not feasible.

> If you want to cut to the chase, you can go straight to [the final hook](#the-final-hook).

## Load More Button

The easiest way to avoid loading more data than absolutely necessary is to load a small, fixed number of items on first render, and place a 'Load More' button at the bottom.

Go ahead, scroll to the bottom of the list and click 'Load More'. I've added a small checkbox to simulate network latency. It will add a 2 second delay before loading the next batch of items. 

<SimpleListContainer items={5} ListComponent={SimpleList} />

Doesn't feel so good, doesn't it?

It's hard as it is to make users click on a 'Load More' button, but expecting them to wait a few seconds for the content to load? No way.

We want to find a way to make content load automagically for the users, and we want the experience to be as smooth as possible for them.

## Using Bounding Rect

OK, so we've decided that a simple 'Load More' button is not good enough for us. Ideally, we would like to know when the user scrolls to the bottom of the list, and automatically trigger a call to get the next items.

We could call the `js>getBoundingClientRect()` of an element at the bottom of the list, and that would give us it's absolute position in the viewport.

Here is the (contrived) code for the list we've rendered before:

```jsx
function SimpleList({ items, loading }) {
  return (
    <List>
      {list.map((item) => (
        <ListItem key={item}>{item}</ListItem>
      ))}
      <Button onClick={loadMore} title={loading ? "loading..." : "Load More!"}>
        {loading ? "loading..." : "Load More!"}
      </Button>
    </List>
  );
}
```

To know if the last item in the list in visible, we could use a callback ref like so:

```jsx
function SimpleList({ items, loading }) {
  const ref = useCallback((refElement) => {
    if (!refElement) {
      return;
    }

    const rect = refElement.getBoundingClientRect();
  }, []);

  return (
    <List>
      {list.map((item, index, array) => (
        <ListItem key={item} ref={index === array.length - 1 ? ref : undefined}>
          {item}
        </ListItem>
      ))}
      <Button onClick={loadMore} title={loading ? "loading..." : "Load More!"}>
        {loading ? "loading..." : "Load More!"}
      </Button>
    </List>
  );
}
```

Our `rect` will look something like this:

```json
{
  "bottom": 455.375,
  "height": 64,
  "left": 682.09375,
  "right": 746.09375,
  "top": 391.375,
  "width": 64,
  "x": 682.09375,
  "y": 391.375
}
```

In order to use that information to calculate whether an element is on screen we can use the `top` and `bottom` attributes.

The `top` attribute tells us how far (in pixels) the top of the element in from the top of the viewport. If `top` is negative, that means the top of the element is above the viewport.

The `bottom` attribute tells us how far the bottom of the element is from the top of the viewport. If `bottom` is negative, that means that the entire element is above the viewport.

Now we can use both attributes to say that if `top` >= 0 and `bottom` <= screen height.

For partial visibility we could check whether `top` < 0 and `bottom` >= 0 (if the element is partially visible from the top of screen), or `top` >= 0 and `bottom` > screen height (if the element is partially visible from the bottom of the screen).

Great, now we can tell whether an element is in view at a certain point in time, but that's still not good enough. We want to know _when_ an element enters the screen.

To do that, we can attach an event handler on the `window` object, listening for the `scroll` event.

```js
window.addEventListener("scroll", function () {
  const position = refElement.getBoundingClientRect();

  if (position.top >= 0 && position.bottom <= window.innerHeight) {
    // Element is fully visible
  }

  if (position.top < window.innerHeight && position.bottom >= 0) {
    // Element is partially visible
  }
});
```

Boom. Done. ðŸ¥³

No, not really - the 'scroll' event has some serious performance issues, making it a big no-no in meaningful application without some performance maneuvers.

## Intersection Observer

The [Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API) is the (not so) new kid on the block. It provides an asynchronous API to detect inetrsection of elements with out viewport.

From MDN:

> The Intersection Observer API provides a way to asynchronously observe changes in the intersection of a target element with an ancestor element or with a top-level document's viewport.

It solves all the issues of the `scroll` event handler, and saves us from doing math to know when (and how much!) an element is intersecting with our viewport.

With an Intersection Observer, making something like this becomes super easy. Scroll until you see the box.

<CodeShiftingBox />

See how the box is changing it's color when it enters the viewport? We've achieved that with the help of an Intersection Observer.

To create an Intersection Observer, you first need to get a ref of the element we wish to be notified when it enters the viewport.

This can be done with a callback ref, same as we did before. Here's a contrvied example from the color shifting box example above.

```jsx
const ColorShiftingBox = () => {
  const boxRef = useCallback((node) => {
    // `node` is a ref to the box element
  }, []);

  return (
    <CodeSnippetWrapper>
      <Wrapper>
        <ScrollMe>Scroll Me!</ScrollMe>
        <BoxWrapper>
          <Box ref={boxRef} />
        </BoxWrapper>
      </Wrapper>
    </CodeSnippetWrapper>
  );
};
```

Now, we want to instantiate an Intersection Observer object and have it monitor our `node`, and we want it to invoke a certain callback whenever the visibility status of our `node` is changing:

```jsx
const ColorShiftingBox = () => {
  const callback = useCallback(() => {
    // highlight-line
    console.log("Status changed!"); // highlight-line
  }, []); // highlight-line

  const boxRef = useCallback(
    (node) => {
      if (!node) {
        return;
      }

      const intersectionObserver = new intersectionObserver(callback); // highlight-line
      intersectionObserver.observe(node); // highlight-line
    },
    [callback]
  );

  return (
    <CodeSnippetWrapper>
      <Wrapper>
        <ScrollMe>Scroll Me!</ScrollMe>
        <BoxWrapper>
          <Box ref={boxRef} />
        </BoxWrapper>
      </Wrapper>
    </CodeSnippetWrapper>
  );
};
```

I've highlighted the new parts - we create a `callback` function to be invoked, and we create a new `intersectionObserver` object with our `callback` as a parameter. Then, we call `.observe()` method and give it our node as a parameter.

That's about it. Now, whenever out `node` enters or leaves the viewport our `callback` wil be invoked. How can we now know what the state of the `node` is?

The trick is that our callback receives 2 parameters. The second one is the `IntersectionObserver` object that triggered the callback, and the first one is an array of [IntersectionObserverEntries](https://developer.mozilla.org/en-US/docs/Web/API/IntersectionObserverEntry).

Why do we get an array? Simple - we can use a single `IntersectionObserver` to monitor multiple nodes. I'll touch on it later, but for now since we're only monitoring one node we can assume that the list contains a single `IntersectionObserverEntry`.

Each `IntersectionObserverEntry` contains some very interesting arguments. I'll leave it up to you to dig through the docs to learn about all of them, but for out purposes we only need one argument - `isIntersecting`.

It's a boolean value that will tell us whether our node is in the viewport (`isIntersecting === true`) or out of the viewport (`isIntersecting === false`).

To log whether out node is in the viewport of not, we can use the `isIntersecting` property like so:

```jsx
const ColorShiftingBox = () => {
  const callback = useCallback((entries) => {
    // highlight-line
    console.log(entries[0].isIntersecting); // highlight-line
  }, []);

  const boxRef = useCallback(
    (node) => {
      if (!node) {
        return;
      }

      const intersectionObserver = new intersectionObserver(callback);
      intersectionObserver.observe(node);
    },
    [callback]
  );

  return (
    <CodeSnippetWrapper>
      <Wrapper>
        <ScrollMe>Scroll Me!</ScrollMe>
        <BoxWrapper>
          <Box ref={boxRef} />
        </BoxWrapper>
      </Wrapper>
    </CodeSnippetWrapper>
  );
};
```

That's great, and it works - but it's not very flexible. If we wanted to use that elsewhere we'd have to write it all over again. Luckily, the folks over at the React team have given us hooks. Let's extract what we've made to a hook.

We'd want out hook's API to be very minimal, so it's dead simple to use.

```jsx
const ColorShiftingBox = () => {
  const callback = useCallback(() => {
    // This should be called only when the Box is intersecting.
  }, []);

  const boxRef = useInfiniteScroll(callback); // highlight-line

  return (
    <CodeSnippetWrapper>
      <Wrapper>
        <ScrollMe>Scroll Me!</ScrollMe>
        <BoxWrapper>
          <Box ref={boxRef} />
        </BoxWrapper>
      </Wrapper>
    </CodeSnippetWrapper>
  );
};
```

## Creating the Hook

We can extract what we've made simply like so:

```js
function useInfiniteScroll(callbackParam) {
  const callback = useCallback(
    (entries) => {
      if (entries.length === 0) {
        return;
      }

      if (entries[0].isIntersecting) {
        callbackParam();
      }
    },
    [callbackParam]
  );

  const infiniteScrollRef = useCallback(
    (node) => {
      if (!node) {
        return;
      }

      const intersectionObserver = new IntersectionObserver(callback);
      intersectionObserver.observe(node);
    },
    [callback]
  );

  return infiniteScrollRef;
}
```

Using this hook is simple. All you need is to call the hook with your `load more` callback, set the ref to whichever component you wish to trigger the request, and VoilÃ !

```jsx
const SimpleListWithHook = ({ list, loading, loadMore }) => {
  const infiniteScrollRef = useInfiniteScroll(loadMore); // highlight-line

  return (
    <CodeSnippetWrapper>
      <ListWrapper>
        <Wrapper>
          <List>
            {list.map((item, index, array) => (
              <ListItem
                key={item}
                ref={index === array.length - 1 ? infiniteScrollRef : undefined} // highlight-line
              >
                {item}
              </ListItem>
            ))}
            <Spacer />
          </List>
          {loading && <Loading>Loading...</Loading>}
        </Wrapper>
      </ListWrapper>
    </CodeSnippetWrapper>
  );
};
```

Note that the trick here is that I attach the `infiniteScrollRef` to the last component in the array. This makes it so new elements are fetched only when the user scrolls to the bottom of the list. 

I could attach it to any other element, triggering the fetch sooner. 

In the real world you'll need to find _your_ sweet spot - where your user gets the most seamless experience, but you don't overfetch in a way that causes you trouble.

Here's a running example of this component. You can play around with it. You'll quickly notice that it works _for the most part_, but it's still pretty finicky.

<SimpleListContainer
  simulateLatency
  items={10}
  ListComponent={SimpleListWithHook}
  hookVersion={1}
  initialSimulateLatency
/>

There are some things we can do to improve the hook and make it work event better.

## The final hook

Let's add an `isActive` parameter to the hook, so we can avoid triggering our `load more` callback if we're in the middle of a request.

Note that we're disconnecting our `observer` before we're creating a new one, and we've also added a `useEffect` to make sure our `observer` is disconnected. We don't want any leaks in our code!

```js
function useInfiniteScroll(callbackParam, isActive) { // highlight-line
  const observer = useRef(null);

  const callback = useCallback(
    (entries) => {
      if (entries.length === 0) {
        return;
      }

      if (entries[0].isIntersecting && isActive) { // highlight-line
        callbackParam();
      }
    },
    [callbackParam, isActive] // highlight-line
  );

  const infiniteScrollRef = useCallback(
    (node) => {
      if (!node) {
        return;
      }

      observer.current?.disconnect(); // highlight-line

      observer.current = new IntersectionObserver(callback);
      observer.current.observe(node);
    },
    [callback]
  );

  useEffect(() => { // highlight-line
    return () => observer.current?.disconnect(); // highlight-line
  }, []); // highlight-line

  return infiniteScrollRef;
}
```

And here's our box list with the final hook.

<SimpleListContainer
  simulateLatency
  items={10}
  ListComponent={SimpleListWithHook}
  hookVersion={2}
  initialSimulateLatency
/>

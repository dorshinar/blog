import Cover from "./cover.jpg";
import { Fragment } from "react";
import { getPostMetadata } from "@/utils/get-metadata";

export const meta = {
  title: "Creating a tree-shakable library with tsup",
  date: "2023-09-15",
  description:
    "Tree shaking is a crucial part of Javascript libraries, but it can be a tricky feat to achieve.",
  slug: "treeshaking-with-tsup",
  published: false,
  cover: Cover,
  coverImageCredit: (
    <Fragment>
      Photo by{" "}
      <a href="https://unsplash.com/@maritaextrabold">Marita Kavelashvili</a> on{" "}
      <a href="https://unsplash.com/photos/ugnrXk1129g">Unsplash</a>
    </Fragment>
  ),
  coverImageAlt: "A top-down view of a forest full of trees",
};

export const metadata = getPostMetadata(meta);

<PostHeader meta={meta} />

At work we had a major project where we started developing a component library, distributed via NPM and consumed by several applications. We were bundling our library with [tsup](https://tsup.egoist.dev/) which worked great.

Or so I thought.

While the library was properly bundled, and build times were very quick thanks to [ESBuild](https://esbuild.github.io/), I noticed that our application bundles were big. Too big to seem reasonable.

Importing our `<Button />{:jsx}` component, [Import Cost](https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost) reported 97Kb added to our bundle. Don't get me wrong, we do have nice buttons, but certainly not 97Kb worth of buttons. Importing `*.svg` icons resulted in similar bundle size added to our application's bundle.

I tested it in multiple environments. Both `webpack` and `vite` behaved similarly, so I figured out our library was not as tree-shakable as I thought it would be.

As it turns out, creating a tree-shakable library can be quite tricky. In this post I'll walk you through how I set our component library to be tree-shakable with `tsup`.

<Message>
  Only interested in the final config? [Skip to the end](#the-final-config).
</Message>

## What is tree shaking?

First, an introduction to tree-shaking. Taken from the [webpack documentation](https://webpack.js.org/guides/tree-shaking/):

<Message>
  Tree shaking is a term commonly used in the JavaScript context for dead-code
  elimination. It relies on the static structure of ES2015 module syntax, i.e.
  import and export. The name and concept have been popularized by the ES2015
  module bundler rollup.
</Message>

To illustrate how it works, let's say we are working on a component library for the company you work for. We currently have 2 components - a `Button` component and a `Dialog` component.

Our `Button` component is very simple:

```tsx
export function Button(props: HTMLAttributes<HTMLButtonProps>) {
  return <button {...props} />;
}
```

But for the `Dialog` component we'll use the excellent `@radix-ui/react-dialog`. I pulled the example straight from their [docs](https://www.radix-ui.com/primitives/docs/components/dialog).

```tsx
import React from "react";
import * as Dialog from "@radix-ui/react-dialog";
import { Cross2Icon } from "@radix-ui/react-icons";

export function Dialog() {
  return (
    <Dialog.Root>
      <Dialog.Trigger asChild>
        <button>Edit profile</button>
      </Dialog.Trigger>
      <Dialog.Portal>
        <Dialog.Overlay />
        <Dialog.Content>
          <Dialog.Title>Edit profile</Dialog.Title>
          <Dialog.Description>
            Make changes to your profile here. Click save when you're done.
          </Dialog.Description>
          <Dialog.Close asChild>
            <button aria-label="Close">
              <Cross2Icon />
            </button>
          </Dialog.Close>
        </Dialog.Content>
      </Dialog.Portal>
    </Dialog.Root>
  );
}
```

Without any other external dependencies, our button component weights about 99 bytes, and our dialog weighs about 50kB (minified, not gzipped).

To consume our component in an application we bundle them together, produce an `index.js` file, publish to `npm` and we have a library.

Different application may import different components from our library. Some only need the button, others only the dialog and some would need both. Ideally, when we are building the consuming application we would like the bundle of each application to only contain the code it _actually_ uses.

Without tree-shaking, each application that uses the `<Button>{:jsx}` component will have 51.9kB _that it doesn't need_. As our library grows larger and larger in size, this will become an issue. It not unheard of to have component libraries that contain 100kB+, where each application only needs a sliver of.

We definitely don't need 100kB extra in our landing page.

To address this issue, bundlers such as webpack and rollup perform an operation called tree-shaking. In the tree-shaking process the bundlers will scan our code to figure our what external pieces of code we imported, and they will only include in our final bundle the code we imported.

## Requirements for tree-shaking

### ESM

To get tree-shaking working most reliably, you should distribute your code in ESM format. ESM uses statically analyzable `export/import` statements which bundlers can take advantage of when bundling our code.

Both webpack and rollup support it as well as [all modern browsers](https://caniuse.com/?search=esm%20module), so it's a safe choice as a compilation target.

To output ESM when bundling with `tsup`, the default bundle format is `cjs`. Change that to `esm` either via the command line:

```sh
tsup src/index.ts --format esm
```

Or via the config file:

```js
import { defineConfig } from "tsup";

export default defineConfig({
  format: ["esm"],
});
```

If you are bundling you library with typescript, set the `compilerOptions.module` to `ES2015/ES6/ES2020/ES2022/ESNext`.

### No side effects

The second thing you should do is make sure you code is side-effects free. From the [webpack docs](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free):

<Message>
  A "side effect" is defined as code that performs a special behavior when
  imported, other than exposing one or more exports. An example of this are
  polyfills, which affect the global scope and usually do not provide an export.
</Message>

Basically, any code that performs an action, alters the global state or anything else when imported is considered to have side effects.

This is important because while side effects are rare, if you do have code that is not pure, like polyfills or otherwise, you would probably not want it excluded from your bundle when the imported module is not referenced. This can include CSS files that are imported but not referenced.

```tsx
import "normalize.css";
```

In webpack the config is called `sideEffects` and in rollup it's called `moduleSideEffects`. Both can receive the value `false` to indicate that there are no side effects in the code, or a list of files that _do_ contain side effects.

### Separate files as entry points

For the most part, bundlers can exclude entire file from your build. While rollup may be able to tree-shake unused function and variables in the same file, webpack cannot - so it's best to stick to the lowest common denominator.

What this means for you in practice is that you should either configure your library to have multiple entry points, or have a single entry points that imports and exports your code from separate files. In my experience, both methods yield similar results, so it's up to you to decide which one you prefer.

The `dist/` folder of a library with multiple entry points would look something like that:

```
dist/
├── button.mjs
└── dialog.mjs
```

And when importing code we would import from the relevant file:

```ts
import { Button } from "component-library/button";
```

While this works, it's not very ergonomic when you import multiple things from your component library in the same file:

```ts
import { Button } from "component-library/button";
import { Dialog } from "component-library/dialog";
```

To solve that you can bundle your library so that you still have a single entry point, but it points to separate files that can be excluded individually:

```
dist/
├── index.mjs
├── button.mjs
└── tooltip.mjs
```

And your `index.mjs` would look roughly like this:

```ts
export * from "./button";
export * from "./dialog";
```

And now your imports can look like this:

```ts
import { Button, Dialog } from "component-library";
```

## Bundling a library with `tsup`

Now that we know what we need to do to get tree-shaking to work, let's see how we can do that with `tsup`. `tsup` is a zero-config bundler that uses `esbuild` under the hood. To get it working properly we would need to configure it a bit.

First, install `tsup`:

```sh
npm i tsup -D
# Or yarn
yarn add tsup --dev
# Or pnpm
pnpm add tsup -D
```

The [`tsup`](https://tsup.egoist.dev/#bundle-files) docs will tell you to specify an entry point such as `src/index.js`, and `tsup` will crawl all files imported from that entry point and bundle them together. This is not what we want, as we want to bundle each file separately.

You can see, that if we leave the default configuration, `tsup` will bundle all files together, and out library will not be tree-shakable.

@@@ NUMBERS @@@

To get `tsup` to bundle each file separately, we need to specify the `entry` option. This option accepts a glob pattern, so we can specify all `.ts` files in the `src/` folder:

```ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/**/*.ts"],
  format: ["esm"],
});
```

Don't forget to include `format: ["esm"]`. This will tell `tsup` to output ESM files, which is the only format that supports tree-shaking. You can choose to output `cjs` as well if you want to support older bundlers, but it's not necessary.

If you are working with other file type such as `.tsx`, `.js` or `.jsx` you can add them to the glob pattern, like so:

```ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/**/*@(ts|tsx)"],
  format: ["esm"],
});
```

You can also have `tsup` generate `.dts` files as well.

The last part we need is to let the bundlers that will consume our library know where to import files from, as well as let them know we don't plan on performing any side effects which may make them bail out of tree-shaking.

Update your `package.json` and add the following lines:

```json
{
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    }
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "sideEffects": false
}
```

The `exports` field tells bundlers where to import files from. The `"."` identifier means that imports from the root of the package will be imported from the `default` field.

If we wanted to allow importing from a sub-module, we would specify it as well. For example, to allow importing a CSS file named `style.css`, we would add the following line to the `exports` object:

```json
{
  "style.css": "./dist/style.css"
}
```

The `import` field is for ESM bundlers, and the `require` field is for CJS bundlers. The `default` field is for the default import, and the `types` field is for the types.

Other than that we also specify our `main` file, which is used by older bundlers that are not aware of the `exports` syntax, as well as `types` which is used by typescript, and last we specify that our code has no side effects.

This should be everything you need to bundle a tree-shakable library with `tsup`.

## The final config

The `tsup.config.ts`:

```ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/**/*@(ts|tsx)"],
  dts: true,
  format: ["esm"],
  treeshake: true,
});
```

And the `package.json`:

```json
{
  "exports": {
    ".": {
      "import": {
        "types": "./dist/index.d.mts",
        "default": "./dist/index.mjs"
      },
      "require": {
        "types": "./dist/index.d.ts",
        "default": "./dist/index.js"
      }
    }
  },
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "sideEffects": false
}
```

Finding the right config has been a bit of trial and error for me, so if you have any suggestions or improvements, please let me know.

<Message>No tree were harmed in the making of this post</Message>

<PostFooter {...meta} />
